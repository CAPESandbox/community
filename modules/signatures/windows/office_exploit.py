# Copyright (C) 2018 Kevin Ross
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from lib.cuckoo.common.abstracts import Signature

try:
    import re2 as re
except ImportError:
    import re


class OfficeCVE201711882(Signature):
    name = "office_cve2017_11882"
    description = "The EQNEDT32 equation process created a child process likely indicative of CVE-2017-11882 Office exploit"
    severity = 3
    confidence = 100
    categories = ["exploit", "office"]
    authors = ["Kevin Ross"]
    minimum = "1.3"
    evented = True
    ttps = ["T1203"]  # MITRE v6,7,8
    mbcs = ["OB0009", "E1203"]

    filter_apinames = set(["CreateProcessInternalW"])
    filter_analysistypes = set(["file"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.data = []

    def on_call(self, call, process):
        pname = process["process_name"].lower()
        if pname == "eqnedt32.exe":
            if call["api"] == "CreateProcessInternalW":
                buff = self.get_argument(call, "ApplicationName")
                self.data.append({"created_process": buff})
                if self.pid:
                    self.mark_call()

    def on_complete(self):
        if self.data:
            return True
        else:
            return False


class OfficeFlashLoad(Signature):
    name = "office_flash_load"
    description = "Flash was loaded by Microsoft Office which could be indicative of an embedded Flash exploit"
    severity = 3
    confidence = 80
    categories = ["exploit", "office"]
    authors = ["Kevin Ross"]
    minimum = "1.3"
    evented = True
    ttps = ["T1137", "T1203"]  # MITRE v6,7,8
    mbcs = ["OB0009", "E1203"]

    filter_apinames = set(["CoCreateInstance", "CoGetClassObject"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.pids = []
        self.officeprocs = ["excel.exe", "powerpnt.exe", "winword.exe"]

    def on_call(self, call, process):
        pname = process["process_name"]
        pid = process["process_id"]
        if pname.lower() in self.officeprocs:
            progid = self.get_argument(call, "ProgID").lower()
            if progid.startswith("shockwaveflash.shockwaveflash."):
                if pid not in self.pids:
                    self.pids.append(pid)
                    self.data.append({"flash load": "%s pid %s loaded Flash" % (pname, pid)})
                    if self.pid:
                        self.mark_call()

    def on_complete(self):
        if self.data:
            return True
        else:
            return False


class OfficePostScript(Signature):
    name = "office_postscript"
    description = "Microsoft Word created a PostScript file possibly indicative of an exploit"
    severity = 3
    confidence = 90
    categories = ["exploit", "office"]
    authors = ["Kevin Ross"]
    minimum = "1.3"
    evented = True
    ttps = ["T1059", "T1137", "T1203"]  # MITRE v6,7,8
    mbcs = ["OB0009", "E1059", "E1203"]
    mbcs += ["OC0001", "C0016"]  # micro-behaviour
    references = ["www.fireeye.com/content/dam/fireeye-www/blog/pdfs/twoforonefinal.pdf"]

    filter_apinames = set(["NtWriteFile"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.handles = []

    def on_call(self, call, process):
        pname = process["process_name"]
        pid = process["process_id"]
        if pname.lower() == "winword.exe":
            buf = self.get_argument(call, "Buffer")
            handle = self.get_argument(call, "HandleName")
            if buf.startswith("%!PS-"):
                if handle not in self.handles:
                    self.handles.append(handle)
                    self.data.append({"postscript": "%s pid %s created postscript file %s" % (pname, pid, handle)})
                    if self.pid:
                        self.mark_call()

    def on_complete(self):
        if self.data:
            return True
        else:
            return False


class OfficeCVE201711882Network(Signature):
    name = "office_cve2017_11882_network"
    description = "The EQNEDT32 process established a network connection"
    severity = 4
    categories = ["exploit", "office"]
    authors = ["ditekshen"]
    minimum = "1.3"
    evented = True
    ttps = ["T1071", "T1203"]  # MITRE v6,7,8
    mbcs = ["OB0004", "B0030", "OB0009", "E1203"]
    mbcs += ["OC0006"]  # micro-behaviour

    filter_apinames = set(["ConnectEx", "URLDownloadToFileW"])

    def on_call(self, call, process):
        procname = process["process_name"].lower()
        if procname and procname == "eqnedt32.exe":
            if call["api"] == "ConnectEx":
                ipaddr = self.get_argument(call, "ip")
                self.data.append({"ip": ipaddr})
                if self.pid:
                    self.mark_call()
            elif call["api"] == "URLDownloadToFileW":
                url = self.get_argument(call, "URL")
                fname = self.get_argument(call, "FileName")
                self.data.append({"url": url})
                self.data.append({"file": fname})
                if self.pid:
                    self.mark_call()

    def on_complete(self):
        if len(self.data) == 3:
            self.description = "{0} {1}".format(
                self.description, " downloading a remote file, potentially exploiting CVE-2017-11882"
            )
            return True
        elif self.data:
            self.description = "{0} {1}".format(self.description, ", potentially exploiting CVE-2017-11882")
            return True

        return False


class OfficeCVE202140444(Signature):
    name = "office_cve_2021_40444"
    description = "Office CVE-2021-40444 Exploit Attempt"
    severity = 4
    weight = 3
    categories = ["virus"]
    authors = ["Will Metcalf"]
    minimum = "1.2"
    evented = True

    filter_apinames = set(["NtQueryAttributesFile", "NtCreateFile"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.data = []
        self.office_proc_list = ["wordview.exe", "excel.exe", "powerpnt.exe", "winword.exe"]

    def on_call(self, call, process):
        pname = process["process_name"].lower()
        if pname in self.office_proc_list:
            buff = self.get_argument(call, "FileName")
            if buff and "\\mhtml:" in buff.lower() and "!x-usc:" in buff.lower():
                tmp_dict = {"office_cve_2021_40444": "%s_%s" % (pname, buff)}
                if tmp_dict not in self.data:
                    self.data.append(tmp_dict)
                    if self.pid:
                        self.mark_call()
            elif buff and "\\mhtml:http" in buff.lower() or "\\mhtml:ftp" in buff.lower() and "!" in buff.lower():
                tmp_dict = {"office_cve_2021_40444": "%s_%s" % (pname, buff)}
                if tmp_dict not in self.data:
                    self.data.append(tmp_dict)
                    if self.pid:
                        self.mark_call()

    def on_complete(self):
        if self.data:
            return True
        return False


class OfficeCVE202140444M2(Signature):
    name = "office_cve_2021_40444_m2"
    description = "Office CVE-2021-40444 Method 2 Exploit Attempt"
    severity = 4
    weight = 3
    categories = ["virus"]
    authors = ["Will Metcalf"]
    minimum = "1.2"
    evented = True

    filter_apinames = set(
        [
            "CLSIDFromProgID",
            "UrlCanonicalizeW",
            "InternetCrackUrlW",
            "CoCreateInstance",
            "RegOpenKeyExA",
            "NtCreateFile",
            "NtOpenKeyEx",
            "ShellExecuteExW",
            "RegEnumValueW",
            "RegOpenKeyExW",
            "IsValidURL",
        ]
    )

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.office_proc_list = ["winword.exe", "excel.exe", "powerpnt.exe", "iexplore.exe"]
        self.htmlfcnt_office = {}
        self.global_htmlfile_max = 0
        self.has_cpl_lookup = False
        self.global_has_cab_dl = False
        self.global_has_shellmatch = False
        self.global_has_dot_proto_url = False

    def on_call(self, call, process):
        pname = process["process_name"]
        pid = process["process_id"]
        if pname.lower() in self.office_proc_list:
            if not self.htmlfcnt_office.get(pid, {}):
                self.htmlfcnt_office[pid] = {
                    "pname": pname,
                    "fccnt": 0,
                    "has_cab_dl": False,
                    "has_cpl_lookup": False,
                    "has_known_bad_clsid": False,
                    "has_shellmatch": False,
                    "has_jscript": False,
                    "is_ie": False,
                    "dot_proto_url": False,
                }
                if pname.lower() == "iexplore.exe":
                    self.htmlfcnt_office[pid]["is_ie"] = True
                    if self.pid:
                        self.mark_call()
            if call["api"] == "CLSIDFromProgID" or call["api"] == "CoCreateInstance":
                progid = self.get_argument(call, "ProgID").lower()
                if progid == "htmlfile":
                    if self.htmlfcnt_office.get(pid, {}):
                        self.htmlfcnt_office[pid]["fccnt"] += 1
                elif progid == "jscript":
                    self.htmlfcnt_office[pid]["has_jscript"] = True
                    if self.pid:
                        self.mark_call()
            elif call["api"] in ["UrlCanonicalizeW", "InternetCrackUrlW"]:
                url = self.get_argument(call, "Url")
                if url and ".cab" in url.lower():
                    self.htmlfcnt_office[pid]["has_cab_dl"] = True
                    if self.pid:
                        self.mark_call()
            elif call["api"] == "IsValidURL":
                url = self.get_argument(call, "URL")
                if re.search(r"^\s*\x2e[a-zA-Z]+[A-Za-z0-9]+\x3a[\x2e\x5c\x2f]*\.\.\/\.\.\/", url, re.I):
                    self.htmlfcnt_office[pid]["dot_proto_url"] = True
                    if self.pid:
                        self.mark_call()
            elif call["api"] == "NtCreateFile":
                buff = self.get_argument(call, "FileName")
                if any(x in buff for x in ["\\Content.IE5\\", "\\INetCache\\IE\\"]) and buff.lower().endswith(".cab"):
                    self.htmlfcnt_office[pid]["has_cab_dl"] = True
                    if self.pid:
                        self.mark_call()
            elif call["api"] == "RegOpenKeyExA" or call["api"] == "NtOpenKeyEx":
                buff = ""
                if call["api"] == "RegOpenKeyExA":
                    buff = self.get_argument(call, "SubKey")
                else:
                    buff = self.get_argument(call, "ObjectAttributesName")
                if (
                    buff
                    and buff.lower().endswith("protocols\\name-space handler\\.cpl\\")
                    or buff.lower().endswith("protocols\\name-space handler\\.cpl")
                ):
                    self.htmlfcnt_office[pid]["has_cpl_lookup"] = True
                    if self.pid:
                        self.mark_call()
                if any(
                    buff.lower().endswith(x.lower())
                    for x in ["\\{EDBC374C-5730-432A-B5B8-DE94F0B57217}", "\\{b7771b25-4e74-4168-add9-04062d629d9a}"]
                ):
                    self.htmlfcnt_office[pid]["has_known_bad_clsid"] = True
                    if self.pid:
                        self.mark_call()
            elif call["api"] == "ShellExecuteExW":
                buff = self.get_argument(call, "FilePath")
                if (
                    any(x in buff.lower() for x in [".cpl:", "control.exe"])
                    and any(x in buff.lower() for x in ["../..", "..\\.."])
                    and ".inf" in buff.lower()
                ):
                    self.htmlfcnt_office[pid]["has_shellmatch"] = True
                    if self.pid:
                        self.mark_call()

    def on_complete(self):
        for key in self.htmlfcnt_office:
            tmp_dict = {
                "office_cve_2021_40444": "pname:%s htmlfile:%s has_cab_dl:%s has_known_bad_clsid:%s has_shellmatch:%s is_ie:%s has_jscript:%s dot_proto_url:%s"
                % (
                    self.htmlfcnt_office[key].get("pname"),
                    self.htmlfcnt_office[key].get("fccnt"),
                    self.htmlfcnt_office[key].get("has_cab_dl", False),
                    self.htmlfcnt_office[key].get("has_known_bad_clsid", False),
                    self.htmlfcnt_office[key].get("has_shellmatch", False),
                    self.htmlfcnt_office[key].get("is_ie", False),
                    self.htmlfcnt_office[key].get("has_jscript", False),
                    self.htmlfcnt_office[key].get("dot_proto_url", False),
                )
            }

            if self.htmlfcnt_office[key].get("fccnt", 0) > self.global_htmlfile_max:
                self.global_htmlfile_max = self.htmlfcnt_office[key].get("fccnt", 0)
            if self.htmlfcnt_office[key].get("has_cab_dl", False):
                self.global_has_cab_dl = True
            if self.htmlfcnt_office[key].get("has_cpl_lookup", False):
                self.has_cpl_lookup = True
            if self.htmlfcnt_office[key].get("dot_proto_url", False):
                self.global_has_dot_proto_url = True
            if (
                (
                    self.htmlfcnt_office[key].get("has_known_bad_clsid", False)
                    or self.htmlfcnt_office[key].get("has_shellmatch")
                    or self.htmlfcnt_office[key].get("has_cpl_lookup")
                    and self.htmlfcnt_office[key].get("has_cab_dl")
                )
                or (
                    self.htmlfcnt_office[key].get("fccnt", 0) > 1
                    and self.htmlfcnt_office[key].get("has_jscript", False)
                    and self.htmlfcnt_office[key].get("has_cab_dl", False)
                    and not self.htmlfcnt_office[key].get("is_ie", True)
                )
                or (self.htmlfcnt_office[key].get("fccnt", 0) > 0 and self.htmlfcnt_office[key].get("dot_proto_url", False))
            ):
                if tmp_dict not in self.data:
                    self.data.append(tmp_dict)

        if not self.data:
            if self.global_has_cab_dl and self.has_cpl_lookup:
                self.data.append({"office_cve_2021_40444": "Cumulative behavior detected CPL Resolution and cab dl"})
            if self.global_has_dot_proto_url and self.global_htmlfile_max > 0:
                self.data.append({"office_cve_2021_40444": "Cumulative behavior detected htmlfile ActiveXObject and Dotproto URL"})
        if self.data:
            # If the only data is marked calls, this is an FP
            if all(item.get("type") == "call" for item in self.data):
                return False
            return True
        return False
