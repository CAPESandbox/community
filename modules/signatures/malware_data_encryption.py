# Copyright (C) 2019 ditekshen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from lib.cuckoo.common.abstracts import Signature

class EncryptPCInfo(Signature):
    name = "encrypts_pcinfo"
    description = "Collects and encrypts information about the computer likely to send to C2 server"
    severity = 3
    categories = ["c&c", "encryption"]
    authors = ["Kevin Ross"]
    minimum = "0.5"
    ttp = ["T1022"]
    evented = True

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.ret = False
        self.compname = str()
        self.username = str()


    filter_apinames = set(["CryptEncrypt", "CryptHashData", "GetComputerNameW", "GetUserNameW"])

    def on_call(self, call, process):
        if call["api"] == "GetComputerNameW":
            self.compname = self.get_argument(call, "ComputerName")
                
        if call["api"] == "GetUserNameW":
            self.username = self.get_argument(call, "Name")
                
        if call["api"].startswith("Crypt"):
            buff = self.get_argument(call, "Buffer")
            if buff and (self.username or self.compname):
                if self.compname.lower() in buff.lower() or self.username.lower() in buff.lower():
                    self.ret = True
                    self.data.append({"data_being_encrypted": buff})

    def on_complete(self):
        return self.ret

class EnryptDataAgentTeslaHTTP(Signature):
    name = "encrypt_data_agenttesla_http"
    description = "AgentTesla HTTP variant keylogger detected encrypting data potentially prior to exfiltrating it"
    severity = 3
    categories = ["keylogger", "infostealer"]
    families = ["AgentTesla"]
    authors = ["ditekshen"]
    minimum = "0.5"
    ttp = ["T1022"]
    evented = True

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.match = False

    filter_apinames = set(["CryptEncrypt"])

    def on_call(self, call, process):
        buff = self.get_argument(call, "Buffer")
        if buff:
            if "type=" in buff and "hwid=" in buff and "pcname=" in buff:
                self.match = True
                self.data.append({"data": buff})

    def on_complete(self):
        return self.match

class EnryptDataNanoCore(Signature):
    name = "encrypt_data_nanocore"
    description = "NanoCore keylogger detected encrypting data potentially prior to exfiltrating it"
    severity = 3
    categories = ["keylogger", "infostealer"]
    families = ["NanoCore"]
    authors = ["ditekshen"]
    minimum = "0.5"
    ttp = ["T1022"]
    evented = True

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.username = str()
        self.hostname = str()
        self.match = False

    filter_apinames = set(["CryptEncrypt", "GetComputerNameW", "GetUserNameW"])

    def on_call(self, call, process):
        if call["api"] == "GetComputerNameW":
            self.hostname = self.get_argument(call, "ComputerName")
        if call["api"] == "GetUserNameW":
            self.username = self.get_argument(call, "Name")
        if call["api"] == "CryptEncrypt":
            buff = self.get_argument(call, "Buffer")
            if buff:
                if buff.startswith("\\x00\\x00\\x00\\x00\\x12") and "\\x0c\\x07" in buff:
                    if self.hostname and self.username:
                        combo = self.hostname + "\\" + self.username
                        if combo in buff:
                            self.match == True

    def on_complete(self):
        return self.match

class EnryptDataAgentTeslaHTTPT2(Signature):
    name = "encrypt_data_agentteslat2_http"
    description = "AgentTesla v2 HTTP variant keylogger detected encrypting data potentially prior to exfiltrating it"
    severity = 3
    categories = ["keylogger", "infostealer"]
    families = ["Predator"]
    authors = ["ditekshen"]
    minimum = "0.5"
    ttp = ["T1022"]
    evented = True

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.username = str()
        self.hostname = str()
        self.match = False

    filter_apinames = set(["CryptEncrypt", "GetComputerNameW", "GetUserNameW"])

    def on_call(self, call, process):
        if call["api"] == "GetComputerNameW":
            self.hostname = self.get_argument(call, "ComputerName")
        if call["api"] == "GetUserNameW":
            self.username = self.get_argument(call, "Name")
        if call["api"] == "CryptEncrypt":
            buff = self.get_argument(call, "Buffer")
            if buff:
                if "22afd24bbac47acb3f315177181b7d3cb7cd0270291f14b3" in buff or "0801a7d44564d53e2d9e9871eae7aab021d0180ac9f508" in buff:
                    if self.hostname and self.username:
                        combo = self.hostname + "/" + self.username
                        if combo in buff:
                            self.match == True

    def on_complete(self):
        return self.match
